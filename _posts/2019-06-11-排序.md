---
layout: post
title:  "排序算法"
description: "基本的排序算法分为冒泡排序、希尔排序、快速排序、选择排序、插入排序"
categories: java
date:   2019-06-11 09:40:42 +0800
---

基本的排序算法分为冒泡排序、希尔排序、快速排序、选择排序、插入排序

### 冒泡排序

#### 概述

冒泡排序：它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名

#### 算法原理

冒泡排序算法的运作如下：（从后往前）

- 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
- 针对所有的元素重复以上的步骤，除了最后一个。
- 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较

#### 算法稳定性

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

#### 算法描述

```java
public static void main(String[] args) {
    int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
    System.out.println("排序之前：");
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
    int swap;
    for (int i = 0; i < a.length - 1; i++) {
        for (int j = i + 1; j < a.length; j++) {
            if (a[i] > a[j]) {
                swap = a[j];
                a[j] = a[i];
                a[i] = swap;
            }
        }
    }
    System.out.println();
    System.out.println("排序之后：");
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
}
```

#### 执行结果

```
排序之前：
49 38 65 97 76 13 27 49 78 34 12 64 1 
排序之后：
1 12 13 27 34 38 49 49 64 65 76 78 97
```

### 希尔排序

#### 概述

希尔排序和直接插入排序一样，都是插入排序，但是它改进了直接插入排序，该方法又称缩小增量排序

#### 算法原理

希尔算法的运作如下：（从后往前）

先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内部进行直接插入排序，然后，取第二个增量d2<d1重复上述分组和排序，直至所取的增量dt＝1，即所有记录放在同一组中进行直接插入排序为止。

一般的初次取序列的一半为增量，以后每次减半，直到增量为1。

#### 算法稳定性

由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以shell排序是不稳定的。

#### 算法描述

```java
public static void main(String[] args) {
    int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
    System.out.println("排序之前：");
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
    //希尔排序
    int d = a.length;
    while (true) {
        d = d / 2;
        for (int x = 0; x < d; x++) {
            for (int i = x + d; i < a.length; i = i + d) {
                int temp = a[i];
                int j;
                for (j = i - d; j >= 0 && a[j] > temp; j = j - d) {
                    a[j + d] = a[j];
                }
                a[j + d] = temp;
            }
        }
        if (d == 1) {
            break;
        }
    }
    System.out.println();
    System.out.println("排序之后：");
    for (int i = 0; i < a.length; i++) {
        System.out.print(a[i] + " ");
    }
}
```

#### 执行结果

```
排序之前：
49 38 65 97 76 13 27 49 78 34 12 64 1 
排序之后：
1 12 13 27 34 38 49 49 64 65 76 78 97 
```

### 快速排序

#### 概述

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

#### 算法原理

通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。

#### 算法稳定性

不稳定。

#### 算法描述

```java
public static void main(String[] args) {
        int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
        System.out.println("排序之前：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        sort(a, 0, a.length-1);
        System.out.println();
        System.out.println("排序之后：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
    }

    public static void sort(int arr[], int low, int high) {
        int l = low;
        int h = high;
        int povit = arr[low];

        while (l < h) {
            while (l < h && arr[h] >= povit)
                h--;
            if (l < h) {
                arr[l] = arr[h];
                l++;
            }

            while (l < h && arr[l] <= povit)
                l++;

            if (l < h) {
                arr[h] = arr[l];
                h--;
            }
        }
        arr[l] = povit;
        if (l - 1 > low) sort(arr, low, l - 1);
        if (h + 1 < high) sort(arr, h + 1, high);
    }
```

#### 执行结果

```
排序之前：
49 38 65 97 76 13 27 49 78 34 12 64 1 
排序之后：
1 12 13 27 34 38 49 49 64 65 76 78 97 
```

### 选择排序

#### 概述

选择排序：每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。

#### 算法原理

选择排序很简单，他的步骤如下：

1. 从左至右遍历，找到最小(大)的元素，然后与第一个元素交换。
2. 从剩余未排序元素中继续寻找最小（大）元素，然后与第二个元素进行交换。
3. 以此类推，直到所有元素均排序完毕。

#### 算法稳定性

不稳定。

#### 算法描述

```java
    public static void main(String[] args) {
        int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
        System.out.println("排序之前：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        selectSort(a);
        System.out.println();
        System.out.println("排序之后：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
    }
    public static void selectSort(int[] a) {
        if((a == null) || (a.length == 0))
            return ;
        for(int i = 0;i < a.length - 1;i ++){
            int minIndex = i; // 无序区的最小数据数组下标
            for(int j = i + 1;j < a.length;j ++){
                // 在无序区中找到最小数据并保存其数组下标
                if(a[j] < a[minIndex]){
                    minIndex = j;
                }
            }
            // 将最小元素放到本次循环的前端
            int temp = a[i];
            a[i] = a[minIndex];
            a[minIndex] = temp;
        }
    }
```

#### 执行结果

```
排序之前：
49 38 65 97 76 13 27 49 78 34 12 64 1 
排序之后：
1 12 13 27 34 38 49 49 64 65 76 78 97 
```

### 插入排序

#### 概述

插入排序包括 直接插入排序和希尔排序

直接插入排序的基本操作是：假设第一个元素是有序的，每次从无序表中取出第一个元素，把它插入到有序表的合适位置，从而得到一个新的，记录数增1的有序表

第一种方式：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则交换，直到找到大于该元素的就则停止；
4. 如果该元素大于前面的元素（已排序），则重复步骤2
5. 重复步骤2~4 直到所有元素都排好序 。

第二种方式：

1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素小于前面的元素（已排序），则依次与前面元素进行比较如果小于则继续与前面的的数比较，直到找到大于该元素的就则停止；
4. 将该位置后面的元素整体移动一位，再交换
5. 重复步骤2~4 直到所有元素都排好序 。

两种方式，第一种是逐个交换，第二种是先找到，再整体后移，最后进行交换

#### 算法原理

直接插入排序算法的运作如下

- 第一个元素默认有序，从第二个元素与它前面的元素进行比较
- 如果第二个元素比第一个元素小，则将该元素用临时变量来保存，并将他前面的元素进行后移
- 一直移动到比该元素小的位置，将元素插入到该位置

#### 算法稳定性

插入排序是在一个已经有序的小序列的基础上，一次插入一个元素。当然，刚开始这个有序的小序列只有1个元素，就是第一个元素。比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么插入元素把想插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。

#### 算法描述

```java
    public static void main(String[] args) {
        int[] a = {49, 38, 65, 97, 76, 13, 27, 49, 78, 34, 12, 64, 1};
        System.out.println("排序之前：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
        insertSort(a);
        System.out.println();
        System.out.println("排序之后：");
        for (int i = 0; i < a.length; i++) {
            System.out.print(a[i] + " ");
        }
    }

    private static int[] insertSort(int[] arr) {
        if (arr == null || arr.length < 2) {
            return arr;
        }
        for (int i = 1; i < arr.length; i++) {
            int temp = arr[i];
            int indx = 0;
            for (int j = i; j > 0; j--) {
                if (arr[j] < arr[j - 1]) {
                    arr[j] = arr[j - 1];
                    indx = j - 1;
                } else {
                    break;
                }
                arr[indx] = temp;
            }
        }
        return arr;
    }
```

#### 执行结果

```
排序之前：
49 38 65 97 76 13 27 49 78 34 12 64 1 
排序之后：
1 12 13 27 34 38 49 49 64 65 76 78 97 
```

### 排序算法比较总结

| 排序算法     | 平均时间复杂度 | 最坏时间复杂度 | 空间复杂度 | 是否稳定 |
| :----------- | :------------- | :------------- | :--------- | :------- |
| 冒泡排序     | O（n2）        | O（n2）        | O（1）     | 是       |
| 选择排序     | O（n2）        | O（n2）        | O（1）     | 不是     |
| 直接插入排序 | O（n2）        | O（n2）        | O（1）     | 是       |
| 归并排序     | O(nlogn)       | O(nlogn)       | O（n）     | 是       |
| 快速排序     | O(nlogn)       | O（n2）        | O（logn）  | 不是     |
| 堆排序       | O(nlogn)       | O(nlogn)       | O（1）     | 不是     |
| 希尔排序     | O(nlogn)       | O（ns）        | O（1）     | 不是     |
| 计数排序     | O(n+k)         | O(n+k)         | O(n+k)     | 是       |
| 基数排序     | O(N∗M)         | O(N∗M)         | O(M)       | 是       |